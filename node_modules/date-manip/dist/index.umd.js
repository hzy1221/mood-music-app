(function(global, factory) {
  typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, factory(global.dateManip = {}));
})(this, function(exports2) {
  "use strict";
  function isObject(value) {
    return value !== null && typeof value === "object";
  }
  function isNumber(value) {
    return typeof value === "number" && value === value;
  }
  /*! date-manip v2.0.4 | MIT License */
  const MS_IN_SECOND = 1e3;
  const MS_IN_MINUTE = 6e4;
  const MS_IN_HOUR = 36e5;
  const MS_IN_DAY = 864e5;
  const rangeOfUnits = [
    "time",
    "year",
    "month",
    "date",
    "day",
    "hour",
    "minute",
    "second",
    "millisecond",
    "utcOffset"
  ];
  /*! date-manip v2.0.4 | MIT License */
  function addMilliseconds(date, ms) {
    date.setTime(+date + ms);
    return date;
  }
  /*! date-manip v2.0.4 | MIT License */
  function addDays(date, days) {
    return addMilliseconds(date, days * MS_IN_DAY);
  }
  /*! date-manip v2.0.4 | MIT License */
  function addHours(date, hours) {
    return addMilliseconds(date, hours * MS_IN_HOUR);
  }
  /*! date-manip v2.0.4 | MIT License */
  function addMinutes(date, minutes) {
    return addMilliseconds(date, minutes * MS_IN_MINUTE);
  }
  /*! date-manip v2.0.4 | MIT License */
  function isLeapYear$1(year) {
    return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
  }
  /*! date-manip v2.0.4 | MIT License */
  const arr = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  const arr2 = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  function daysOfYear(year) {
    return isLeapYear$1(year) ? arr2 : arr;
  }
  /*! date-manip v2.0.4 | MIT License */
  function daysInMonth(date) {
    return daysOfYear(date.getFullYear())[date.getMonth()];
  }
  /*! date-manip v2.0.4 | MIT License */
  function addMonths(date, months) {
    const expectedMonth = date.getMonth() + months;
    const tempMaxDay = daysInMonth(new Date(date.getFullYear(), expectedMonth, 1, 0, 0, 0, 0));
    const currentDay = date.getDate();
    date.setMonth(expectedMonth, currentDay > tempMaxDay ? tempMaxDay : currentDay);
    return date;
  }
  /*! date-manip v2.0.4 | MIT License */
  function addSeconds(date, seconds) {
    return addMilliseconds(date, seconds * MS_IN_SECOND);
  }
  /*! date-manip v2.0.4 | MIT License */
  function addYears(date, years) {
    return addMonths(date, years * 12);
  }
  /*! date-manip v2.0.4 | MIT License */
  const units = rangeOfUnits.reduce((acc, unit) => {
    acc[unit.toUpperCase()] = unit;
    return acc;
  }, {});
  /*! date-manip v2.0.4 | MIT License */
  const { DATE: DATE$5, DAY: DAY$6, HOUR: HOUR$7, MILLISECOND: MILLISECOND$3, MINUTE: MINUTE$7, MONTH: MONTH$7, SECOND: SECOND$7, TIME: TIME$1, YEAR: YEAR$7 } = units;
  const compatUnits = {};
  function mapUnit(key, ...args) {
    for (let i = 0; i < arguments.length; i++) {
      compatUnits[arguments[i]] = key;
    }
  }
  mapUnit(YEAR$7, "Y", "y", "years");
  mapUnit(MONTH$7, "M", "months");
  mapUnit(DATE$5, "D", "dates");
  mapUnit(DAY$6, "d", "days");
  mapUnit(HOUR$7, "h", "hours");
  mapUnit(MINUTE$7, "m", "minutes");
  mapUnit(SECOND$7, "s", "seconds");
  mapUnit(MILLISECOND$3, "ms", "milliseconds");
  mapUnit(TIME$1, "t");
  function normalizeUnit(u) {
    return compatUnits[u];
  }
  /*! date-manip v2.0.4 | MIT License */
  const { DAY: DAY$1$1, HOUR: HOUR$1$1, MINUTE: MINUTE$1$1, MONTH: MONTH$1$1, SECOND: SECOND$1$1, YEAR: YEAR$1$1 } = units;
  function addNumber(date, num, unit) {
    unit = normalizeUnit(unit);
    switch (unit) {
      case YEAR$1$1:
        return addYears(date, num);
      case MONTH$1$1:
        return addMonths(date, num);
      case DAY$1$1:
        return addDays(date, num);
      case HOUR$1$1:
        return addHours(date, num);
      case MINUTE$1$1:
        return addMinutes(date, num);
      case SECOND$1$1:
        return addSeconds(date, num);
      default:
        return addMilliseconds(date, num);
    }
  }
  const { DAY: DAY$5, HOUR: HOUR$6, MINUTE: MINUTE$6, MONTH: MONTH$6, SECOND: SECOND$6, YEAR: YEAR$6 } = units;
  function addObject(date, obj, times) {
    let time = 0;
    let expectedMonth = 0;
    let expectedDay = 0;
    Object.entries(obj).forEach(([unit, num]) => {
      unit = normalizeUnit(unit);
      num *= times;
      switch (unit) {
        case YEAR$6:
          expectedMonth += num * 12;
          return;
        case MONTH$6:
          expectedMonth += date.getMonth() + num;
          return;
        case DAY$5:
          expectedDay = num;
          return;
        case HOUR$6:
          num *= MS_IN_HOUR;
          break;
        case MINUTE$6:
          num *= MS_IN_MINUTE;
          break;
        case SECOND$6:
          num *= MS_IN_SECOND;
          break;
      }
      time += num;
    });
    if (expectedMonth) {
      const tempMaxDay = daysInMonth(new Date(date.getFullYear(), expectedMonth, 1, 0, 0, 0, 0));
      const currentDay = date.getDate();
      date.setMonth(expectedMonth, (currentDay > tempMaxDay ? tempMaxDay : currentDay) + expectedDay);
    }
    return addMilliseconds(date, time);
  }
  /*! date-manip v2.0.4 | MIT License */
  function add(date, num, unit) {
    return isObject(num) ? addObject(date, num, 1) : addNumber(date, num, unit);
  }
  /*! date-manip v2.0.4 | MIT License */
  const { YEAR: YEAR$5, MONTH: MONTH$5, DATE: DATE$4, HOUR: HOUR$5, MINUTE: MINUTE$5, SECOND: SECOND$5, MILLISECOND: MILLISECOND$2, UTC_OFFSET: UTC_OFFSET$1 } = units;
  function escapeRegex(str) {
    return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }
  const TOKEN_MAP = {
    YYYY: { pattern: "(\\d{1,4})", key: YEAR$5 },
    // 年份
    // YY: { pattern: '(\\d{1,2})', key: YEAR }, // 年份
    MM: { pattern: "(\\d{1,2})", key: MONTH$5 },
    // 月份
    DD: { pattern: "(\\d{1,2})", key: DATE$4 },
    // 日期
    HH: { pattern: "(\\d{1,2})", key: HOUR$5 },
    // 小时
    mm: { pattern: "(\\d{1,2})", key: MINUTE$5 },
    // 分钟
    ss: { pattern: "(\\d{1,2})", key: SECOND$5 },
    // 秒
    SSS: { pattern: "(\\d{1,3})", key: MILLISECOND$2 },
    // 毫秒
    Z: { pattern: "(Z|[+-]\\d{2}(?::?\\d{2})?)", key: UTC_OFFSET$1 }
    // 时区
  };
  const TOKEN_KEYS = Object.keys(TOKEN_MAP).sort((a, b) => b.length - a.length);
  const TOKEN_PATTERN = new RegExp(`(${TOKEN_KEYS.join("|")})`, "g");
  function compile(formatString) {
    const matchedTokens = [];
    const pattern2 = escapeRegex(formatString).replace(TOKEN_PATTERN, (m) => {
      matchedTokens.push(m);
      return TOKEN_MAP[m].pattern;
    });
    return { pattern: pattern2, tokens: matchedTokens };
  }
  /*! date-manip v2.0.4 | MIT License */
  function dayOfYear(date, val) {
    const monthDays = daysOfYear(date.getFullYear());
    const currentMonth = date.getMonth();
    let dayCount = date.getDate();
    for (let i = 0; i < currentMonth; i++) {
      dayCount += monthDays[i];
    }
    if (val === void 0) {
      return dayCount;
    }
    date.setTime(+date + (val - dayCount) * MS_IN_DAY);
    return date;
  }
  /*! date-manip v2.0.4 | MIT License */
  function absFloor(v) {
    return v < 0 ? Math.ceil(v) || 0 : Math.floor(v);
  }
  /*! date-manip v2.0.4 | MIT License */
  const BASIC_ISO_REGEX = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
  const EXTENDED_ISO_REGEX = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
  const ISO_TIMES_REGEX = [
    /(\d\d):(\d\d):(\d\d)\.(\d+)/,
    // 'HH:mm:ss.SSSS'
    /(\d\d):(\d\d):(\d\d),(\d+)/,
    // 'HH:mm:ss,SSSS'
    /(\d\d):(\d\d):(\d\d)/,
    // 'HH:mm:ss'
    /(\d\d):(\d\d)/,
    // 'HH:mm'
    /(\d\d)(\d\d)(\d\d)\.(\d+)/,
    // 'HHmmss.SSSS'
    /(\d\d)(\d\d)(\d\d),(\d+)/,
    // 'HHmmss,SSSS'
    /(\d\d)(\d\d)(\d\d)/,
    // 'HHmmss'
    /(\d\d)(\d\d)/,
    // 'HHmm'
    /(\d\d)/
    // 'HH'
  ];
  const TZ_REGEX = /(Z)|([+-]\d\d)(?::?(\d\d))?/;
  const ISO_DATES_REGEX = [
    /(\d{4})-(\d\d)-(\d\d)/,
    // 'YYYY-MM-DD'
    /(\d{4})-(\d\d)/,
    // 'YYYY-MM'
    /(\d{4})(\d\d)(\d\d)/,
    // 'YYYYMMDD'
    /(\d{4})(\d\d)/,
    // 'YYYYMM'
    /(\d{4})/
    // 'YYYY'
  ];
  function autoExtract(input) {
    const dateRet = new Array(8);
    let matches;
    const match = EXTENDED_ISO_REGEX.exec(input) || BASIC_ISO_REGEX.exec(input);
    if (match) {
      const datesLen = ISO_DATES_REGEX.length;
      for (let i = 0; i < datesLen; i++) {
        if (matches = ISO_DATES_REGEX[i].exec(match[1])) {
          for (let j = 0; j < 3; j++) {
            const matched = matches[j + 1];
            dateRet[j] = matched ? +matched : 1;
          }
          if (dateRet[1]) {
            dateRet[1] -= 1;
          }
          break;
        }
      }
      matches = null;
      if (match[3]) {
        for (let i = 0, timesLen = ISO_TIMES_REGEX.length; i < timesLen; i++) {
          if (matches = ISO_TIMES_REGEX[i].exec(match[3])) {
            if (matches[4]) {
              matches[4] = matches[4].padEnd(3, "00");
            }
            for (let j = 1, len = matches.length; j < len; j++) {
              dateRet[j + 2] = +matches[j];
            }
            break;
          }
        }
      }
      matches = null;
      if (match[4]) {
        matches = TZ_REGEX.exec(match[4]);
        if (matches) {
          dateRet[7] = matches[1] ? NaN : +matches[2] * 60 + (matches[3] ? +matches[3] : 0);
        }
      }
      return dateRet;
    }
    return input;
  }
  function createDate(y, m, d, h, minute, s, ms) {
    let date;
    if (y < 100 && y >= 0) {
      date = new Date(y + 400, m, d, h, minute, s, ms);
      if (isFinite(date.getFullYear())) {
        date.setFullYear(y);
      }
    } else {
      date = new Date(y, m, d, h, minute, s, ms);
    }
    return date;
  }
  function createUTCDate(y, m, d, h, minute, s, ms) {
    let date;
    if (y < 100 && y >= 0) {
      y += 400;
      date = new Date(Date.UTC(y, m, d, h, minute, s, ms));
      if (isFinite(date.getUTCFullYear())) {
        date.setUTCFullYear(y);
      }
    } else {
      date = new Date(Date.UTC(y, m, d, h, minute, s, ms));
    }
    return date;
  }
  function createFromArray(input) {
    const utcOffset = input[7];
    const currentDate = /* @__PURE__ */ new Date();
    const isUTC = Number.isNaN(utcOffset);
    const flag = isUTC ? "UTC" : "";
    const currentStuffing = [
      currentDate[`get${flag}FullYear`](),
      currentDate[`get${flag}Month`](),
      currentDate[`get${flag}Date`]()
    ];
    let i = 0;
    const array = new Array(7);
    for (; i < 3 && input[i] == null; ++i) {
      array[i] = currentStuffing[i];
    }
    for (; i < 7; i++) {
      array[i] = input[i] == null ? 0 : input[i];
    }
    let day = array[2];
    if (day === 0) {
      day = 1;
    }
    let minute = array[4];
    if (!isUTC && typeof utcOffset === "number") {
      minute -= utcOffset + currentDate.getTimezoneOffset();
    }
    return (isUTC ? createUTCDate : createDate)(
      array[0],
      array[1],
      day,
      array[3],
      minute,
      array[5],
      array[6]
    );
  }
  function toInteger(val) {
    return parseInt(val, 10);
  }
  function toMonth(val) {
    return parseInt(val, 10) - 1;
  }
  function toMilliseconds(val) {
    return parseInt(val.padEnd(3, "0"), 10);
  }
  function parseTimezone(val) {
    if (val === "Z") {
      return NaN;
    }
    const matches = TZ_REGEX.exec(val);
    return +matches[2] * 60 + (matches[3] ? +matches[3] : 0);
  }
  function extractWithFormat(input, format2) {
    const { pattern: pattern2, tokens: tokens2 } = compile(format2);
    const match = new RegExp(pattern2).exec(input);
    if (!match) {
      return "";
    }
    const parts = [];
    tokens2.forEach((token, i) => {
      const value = match[i + 1];
      switch (token) {
        case "YYYY":
          parts[0] = toInteger(value);
          break;
        // case 'YY':
        //   parts[0] = toInteger(value);
        //   break;
        case "MM":
          parts[1] = toMonth(value);
          break;
        case "DD":
          parts[2] = toInteger(value);
          break;
        case "HH":
          parts[3] = toInteger(value);
          break;
        case "mm":
          parts[4] = toInteger(value);
          break;
        case "ss":
          parts[5] = toInteger(value);
          break;
        case "SSS":
          parts[6] = toMilliseconds(value);
          break;
        case "Z":
          parts[7] = parseTimezone(value);
          break;
      }
    });
    return parts;
  }
  const { DATE: DATE$3, DAY: DAY$4, HOUR: HOUR$4, MILLISECOND: MILLISECOND$1, MINUTE: MINUTE$4, MONTH: MONTH$4, SECOND: SECOND$4, YEAR: YEAR$4, UTC_OFFSET } = units;
  const ASP_NET_JSON_REGEX = /^\/?Date\((-?\d+)/i;
  function parseObject(obj) {
    const array = [];
    Object.entries(obj).forEach(([unit, value]) => {
      unit = normalizeUnit(unit);
      switch (unit) {
        case YEAR$4:
          array[0] = value;
          break;
        case MONTH$4:
          array[1] = value;
          break;
        case DATE$3:
        case DAY$4:
          array[2] = value;
          break;
        case HOUR$4:
          array[3] = value;
          break;
        case MINUTE$4:
          array[4] = value;
          break;
        case SECOND$4:
          array[5] = value;
          break;
        case MILLISECOND$1:
          array[6] = value;
          break;
        case UTC_OFFSET:
          array[7] = value;
          break;
      }
    });
    if (array.length === 0) {
      return /* @__PURE__ */ new Date();
    }
    return createFromArray(array);
  }
  function parseString(input, format2) {
    const extracted = typeof format2 === "string" && format2 ? extractWithFormat(input, format2) : autoExtract(input);
    if (Array.isArray(extracted)) {
      return createFromArray(extracted);
    }
    const matched = ASP_NET_JSON_REGEX.exec(input);
    return new Date(matched !== null ? +matched[1] : Date.parse(extracted));
  }
  function parse(input, format2) {
    let ret;
    if (typeof input === "string") {
      ret = parseString(input, format2);
    } else if (Array.isArray(input)) {
      ret = createFromArray(input);
    } else if (input instanceof Date) {
      ret = new Date(input);
    } else if (isObject(input)) {
      if (input.isValid && input.isValid()) {
        ret = /* @__PURE__ */ new Date(+input);
      } else {
        ret = parseObject(input);
      }
    } else if (isNumber(input)) {
      ret = new Date(input);
    } else if (typeof input === "undefined") {
      ret = format2 ? /* @__PURE__ */ new Date(NaN) : /* @__PURE__ */ new Date();
    } else {
      ret = new Date(Date.parse(input));
    }
    return ret;
  }
  /*! date-manip v2.0.4 | MIT License */
  function diffInDays(date, input, asFloat) {
    const parsed = parse(input);
    const output = (+date - +parsed) / MS_IN_DAY;
    return asFloat ? output : absFloor(output);
  }
  /*! date-manip v2.0.4 | MIT License */
  function diffInHours(date, input, asFloat) {
    const parsed = parse(input);
    const output = (+date - +parsed) / MS_IN_HOUR;
    return asFloat ? output : absFloor(output);
  }
  /*! date-manip v2.0.4 | MIT License */
  function diffInMilliseconds(date, input, asFloat) {
    const parsed = parse(input);
    const output = +date - +parsed;
    return asFloat ? output : absFloor(output);
  }
  /*! date-manip v2.0.4 | MIT License */
  function diffInMinutes(date, input, asFloat) {
    const parsed = parse(input);
    const output = (+date - +parsed) / MS_IN_MINUTE;
    return asFloat ? output : absFloor(output);
  }
  /*! date-manip v2.0.4 | MIT License */
  function monthDiff(a, b) {
    const aTime = +a;
    const bTime = +b;
    if (aTime < bTime) {
      return -monthDiff(b, a);
    }
    const wholeMonthDiff = (b.getFullYear() - a.getFullYear()) * 12 + (b.getMonth() - a.getMonth());
    const anchor = +addMonths(new Date(aTime), wholeMonthDiff);
    let anchor2;
    let adjust;
    if (bTime < anchor) {
      anchor2 = +addMonths(new Date(aTime), wholeMonthDiff - 1);
      adjust = (bTime - anchor) / (anchor - anchor2);
    } else {
      anchor2 = +addMonths(new Date(aTime), wholeMonthDiff + 1);
      adjust = (bTime - anchor) / (anchor2 - anchor);
    }
    return -(wholeMonthDiff + adjust) || 0;
  }
  /*! date-manip v2.0.4 | MIT License */
  function diffInMonths(date, input, asFloat) {
    const parsed = parse(input);
    const output = monthDiff(date, parsed);
    return asFloat ? output : absFloor(output);
  }
  /*! date-manip v2.0.4 | MIT License */
  function diffInSeconds(date, input, asFloat) {
    const parsed = parse(input);
    const output = (+date - +parsed) / MS_IN_SECOND;
    return asFloat ? output : absFloor(output);
  }
  /*! date-manip v2.0.4 | MIT License */
  function diffInYears(date, input, asFloat) {
    const parsed = parse(input);
    const output = monthDiff(date, parsed) / 12;
    return asFloat ? output : absFloor(output);
  }
  /*! date-manip v2.0.4 | MIT License */
  const {
    DAY: DAY$3,
    HOUR: HOUR$3,
    MINUTE: MINUTE$3,
    MONTH: MONTH$3,
    SECOND: SECOND$3,
    YEAR: YEAR$3
  } = units;
  function diff(date, input, unit, asFloat) {
    unit = normalizeUnit(unit);
    switch (unit) {
      case YEAR$3:
        return diffInYears(date, input, asFloat);
      case MONTH$3:
        return diffInMonths(date, input, asFloat);
      // case DATE:
      case DAY$3:
        return diffInDays(date, input, asFloat);
      case HOUR$3:
        return diffInHours(date, input, asFloat);
      case MINUTE$3:
        return diffInMinutes(date, input, asFloat);
      case SECOND$3:
        return diffInSeconds(date, input, asFloat);
      default:
        return diffInMilliseconds(date, input, asFloat);
    }
  }
  /*! date-manip v2.0.4 | MIT License */
  function startOfDate(date, y, m, d) {
    return +new Date(
      y || date.getFullYear(),
      m == null ? date.getMonth() : m,
      d || date.getDate()
    );
  }
  function startOfTime(date, ms) {
    const input = +date;
    return input - input % ms;
  }
  /*! date-manip v2.0.4 | MIT License */
  const { DATE: DATE$2, DAY: DAY$2, HOUR: HOUR$2, MINUTE: MINUTE$2, MONTH: MONTH$2, SECOND: SECOND$2, YEAR: YEAR$2 } = units;
  function endOf(date, unit) {
    unit = normalizeUnit(unit);
    let time = 0;
    switch (unit) {
      case YEAR$2:
        time = startOfDate(date, date.getFullYear() + 1, 0, 1) - 1;
        break;
      case MONTH$2:
        time = startOfDate(date, void 0, date.getMonth() + 1, 1) - 1;
        break;
      case DATE$2:
      case DAY$2:
        time = startOfDate(date) + MS_IN_DAY - 1;
        break;
      case HOUR$2:
        time = startOfTime(date, MS_IN_HOUR) + MS_IN_HOUR - 1;
        break;
      case MINUTE$2:
        time = startOfTime(date, MS_IN_MINUTE) + MS_IN_MINUTE - 1;
        break;
      case SECOND$2:
        time = startOfTime(date, MS_IN_SECOND) + MS_IN_SECOND - 1;
        break;
    }
    time && date.setTime(time);
    return date;
  }
  /*! date-manip v2.0.4 | MIT License */
  function padLeft(val, len) {
    return String(val).padStart(len || 2, "0");
  }
  function dateTimeFormat(date, opts) {
    return new Intl.DateTimeFormat("en-US", opts).format(date);
  }
  function getOrdinalSuffix(day) {
    if (day > 3 && day < 21) {
      return "th";
    }
    switch (day % 10) {
      case 1:
        return "st";
      case 2:
        return "nd";
      case 3:
        return "rd";
      default:
        return "th";
    }
  }
  function timezone(date, together) {
    let offset = date.getTimezoneOffset();
    let prefix;
    if (offset <= 0) {
      prefix = "+";
      offset = Math.abs(offset);
    } else {
      prefix = "-";
    }
    return `${prefix}${padLeft(Math.floor(offset / 60))}${together ? "" : ":"}${padLeft(Math.floor(offset % 60))}`;
  }
  const FORMAT_MAP = {
    // 年份
    yyyy: (d) => d.getFullYear(),
    YYYY: (d) => d.getFullYear(),
    YY: (d) => padLeft(d.getFullYear() % 100),
    // 月份
    MMMM: (d) => dateTimeFormat(d, { month: "long" }),
    MMM: (d) => dateTimeFormat(d, { month: "short" }),
    MM: (d) => padLeft(d.getMonth() + 1),
    M: (d) => d.getMonth() + 1,
    // 日期
    DD: (d) => padLeft(d.getDate()),
    D: (d) => d.getDate(),
    Do: (d) => {
      const day = d.getDate();
      return String(day) + getOrdinalSuffix(day);
    },
    // 星期
    dddd: (d) => dateTimeFormat(d, { weekday: "long" }),
    ddd: (d) => dateTimeFormat(d, { weekday: "short" }),
    dd: (d) => dateTimeFormat(d, { weekday: "narrow" }),
    // 时间
    HH: (d) => padLeft(d.getHours()),
    H: (d) => d.getHours(),
    hh: (d) => padLeft(d.getHours() % 12 || 12),
    h: (d) => d.getHours() % 12 || 12,
    mm: (d) => padLeft(d.getMinutes()),
    m: (d) => d.getMinutes(),
    ss: (d) => padLeft(d.getSeconds()),
    s: (d) => d.getSeconds(),
    SSS: (d) => padLeft(d.getMilliseconds(), 3),
    // 其他
    A: (d) => d.getHours() >= 12 ? "PM" : "AM",
    a: (d) => d.getHours() >= 12 ? "pm" : "am",
    Z: (d) => timezone(d),
    ZZ: (d) => timezone(d, true)
  };
  const tokens = Object.keys(FORMAT_MAP).sort((a, b) => b.length - a.length).join("|");
  const pattern = new RegExp(
    `${tokens}|\\[([^\\]]*)]`,
    "g"
  );
  function format(date, formatString) {
    if (!formatString || formatString === "ISO") {
      return date.toISOString();
    }
    return formatString.replace(pattern, (match, escapeContent) => {
      if (escapeContent) {
        return escapeContent;
      }
      const formatter = FORMAT_MAP[match];
      return formatter ? formatter(date) : match;
    });
  }
  /*! date-manip v2.0.4 | MIT License */
  const { DATE: DATE$1, DAY: DAY$1, HOUR: HOUR$1, MILLISECOND, MINUTE: MINUTE$1, MONTH: MONTH$1, SECOND: SECOND$1, TIME, YEAR: YEAR$1 } = units;
  const mapping = {
    [YEAR$1]: "FullYear",
    [MONTH$1]: "Month",
    [DATE$1]: "Date",
    [DAY$1]: "Day",
    [HOUR$1]: "Hours",
    [MINUTE$1]: "Minutes",
    [SECOND$1]: "Seconds",
    [MILLISECOND]: "Milliseconds",
    [TIME]: "Time"
  };
  const setting = {};
  const getting = {};
  Object.entries(mapping).forEach(([key, method]) => {
    if (key === DAY$1) {
      setting[key] = function(date, val) {
        const day = date.getDay();
        if (val !== day) {
          date.setTime(+date + (val - day) * MS_IN_DAY);
        }
      };
    } else {
      setting[key] = function(date, val) {
        date[`set${method}`](val);
      };
    }
    getting[key] = function(date) {
      return date[`get${method}`]();
    };
  });
  function get(date, unit) {
    const fn = getting[normalizeUnit(unit)];
    return fn ? fn(date) : 0;
  }
  function set(date, unit, val) {
    const fn = setting[normalizeUnit(unit)];
    fn && fn(date, val);
    return date;
  }
  /*! date-manip v2.0.4 | MIT License */
  const { DATE, DAY, HOUR, MINUTE, MONTH, SECOND, YEAR } = units;
  function startOf(date, unit) {
    unit = normalizeUnit(unit);
    let time = 0;
    switch (unit) {
      case YEAR:
        time = startOfDate(date, void 0, 0, 1);
        break;
      case MONTH:
        time = startOfDate(date, void 0, void 0, 1);
        break;
      case DATE:
      case DAY:
        time = startOfDate(date);
        break;
      case HOUR:
        time = startOfTime(date, MS_IN_HOUR);
        break;
      case MINUTE:
        time = startOfTime(date, MS_IN_MINUTE);
        break;
      case SECOND:
        time = startOfTime(date, MS_IN_SECOND);
        break;
    }
    time && date.setTime(time);
    return date;
  }
  /*! date-manip v2.0.4 | MIT License */
  function isAfter(date, input, unit) {
    unit = normalizeUnit(unit);
    const inputMs = +parse(input);
    if (!unit) {
      return +date > inputMs;
    }
    return +startOf(new Date(date), unit) > inputMs;
  }
  /*! date-manip v2.0.4 | MIT License */
  function isBefore(date, input, unit) {
    unit = normalizeUnit(unit);
    const inputMs = +parse(input);
    if (!unit) {
      return +date < inputMs;
    }
    return +endOf(new Date(date), unit) < inputMs;
  }
  /*! date-manip v2.0.4 | MIT License */
  function isBetween(date, from, to, unit, inclusivity) {
    inclusivity = inclusivity || "()";
    return (inclusivity.startsWith("(") ? isAfter(date, from, unit) : !isBefore(date, from, unit)) && (inclusivity.charAt(1) === ")" ? isBefore(date, to, unit) : !isAfter(date, to, unit));
  }
  /*! date-manip v2.0.4 | MIT License */
  function isLeapYear(date) {
    return isLeapYear$1(date.getFullYear());
  }
  /*! date-manip v2.0.4 | MIT License */
  function isSame(date, input, unit) {
    unit = normalizeUnit(unit);
    const inputMs = +parse(input);
    if (!unit) {
      return +date === inputMs;
    }
    return +startOf(new Date(date), unit) <= inputMs && inputMs <= +endOf(new Date(date), unit);
  }
  /*! date-manip v2.0.4 | MIT License */
  function isSameOrAfter(date, input, unit) {
    return !isBefore(date, input, unit);
  }
  /*! date-manip v2.0.4 | MIT License */
  function isSameOrBefore(date, input, unit) {
    return !isAfter(date, input, unit);
  }
  /*! date-manip v2.0.4 | MIT License */
  function isValid(date) {
    return date.toString() !== "Invalid Date";
  }
  /*! date-manip v2.0.4 | MIT License */
  function subDays(date, days) {
    return addDays(date, -days);
  }
  /*! date-manip v2.0.4 | MIT License */
  function subHours(date, hours) {
    return addHours(date, -hours);
  }
  /*! date-manip v2.0.4 | MIT License */
  function subMilliseconds(date, ms) {
    return addMilliseconds(date, -ms);
  }
  /*! date-manip v2.0.4 | MIT License */
  function subMinutes(date, minutes) {
    return addMinutes(date, -minutes);
  }
  /*! date-manip v2.0.4 | MIT License */
  function subMonths(date, months) {
    return addMonths(date, -months);
  }
  /*! date-manip v2.0.4 | MIT License */
  function subSeconds(date, seconds) {
    return addSeconds(date, -seconds);
  }
  /*! date-manip v2.0.4 | MIT License */
  function subYears(date, years) {
    return addMonths(date, -years * 12);
  }
  /*! date-manip v2.0.4 | MIT License */
  function subtract(date, num, unit) {
    return isObject(num) ? addObject(date, num, -1) : addNumber(date, -num, unit);
  }
  exports2.add = add;
  exports2.addDays = addDays;
  exports2.addHours = addHours;
  exports2.addMilliseconds = addMilliseconds;
  exports2.addMinutes = addMinutes;
  exports2.addMonths = addMonths;
  exports2.addSeconds = addSeconds;
  exports2.addYears = addYears;
  exports2.compile = compile;
  exports2.dayOfYear = dayOfYear;
  exports2.daysInMonth = daysInMonth;
  exports2.diff = diff;
  exports2.diffInDays = diffInDays;
  exports2.diffInHours = diffInHours;
  exports2.diffInMilliseconds = diffInMilliseconds;
  exports2.diffInMinutes = diffInMinutes;
  exports2.diffInMonths = diffInMonths;
  exports2.diffInSeconds = diffInSeconds;
  exports2.diffInYears = diffInYears;
  exports2.endOf = endOf;
  exports2.format = format;
  exports2.get = get;
  exports2.isAfter = isAfter;
  exports2.isBefore = isBefore;
  exports2.isBetween = isBetween;
  exports2.isLeapYear = isLeapYear;
  exports2.isSame = isSame;
  exports2.isSameOrAfter = isSameOrAfter;
  exports2.isSameOrBefore = isSameOrBefore;
  exports2.isValid = isValid;
  exports2.parse = parse;
  exports2.set = set;
  exports2.startOf = startOf;
  exports2.subDays = subDays;
  exports2.subHours = subHours;
  exports2.subMilliseconds = subMilliseconds;
  exports2.subMinutes = subMinutes;
  exports2.subMonths = subMonths;
  exports2.subSeconds = subSeconds;
  exports2.subYears = subYears;
  exports2.subtract = subtract;
  exports2.units = units;
  Object.defineProperty(exports2, Symbol.toStringTag, { value: "Module" });
});
