"use strict";
/*! date-manip v2.0.4 | MIT License */
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const fns = require("date-manip");
function _interopNamespaceDefault(e) {
  const n = Object.create(null, { [Symbol.toStringTag]: { value: "Module" } });
  if (e) {
    for (const k in e) {
      if (k !== "default") {
        const d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: () => e[k]
        });
      }
    }
  }
  n.default = e;
  return Object.freeze(n);
}
const fns__namespace = /* @__PURE__ */ _interopNamespaceDefault(fns);
const { parse, get, set } = fns__namespace;
class DateChain {
  constructor(input, format) {
    const _input = input instanceof DateChain ? input._d : input;
    this._i = input;
    this._f = format;
    this._d = parse(_input, format);
  }
  clone() {
    return new DateChain(this, this._f);
  }
  toArray() {
    const date = this._d;
    return [
      get(date, "year"),
      get(date, "month"),
      get(date, "date"),
      get(date, "hours"),
      get(date, "minutes"),
      get(date, "seconds"),
      get(date, "milliseconds")
      // -date.getTimezoneOffset()
    ];
  }
  toDate() {
    return new Date(this._d);
  }
  toISOString() {
    return this._d.toISOString();
  }
  toJSON() {
    return this.toISOString();
  }
  toString() {
    return this._d.toString();
  }
  valueOf() {
    return this._d.valueOf();
  }
}
const proto = DateChain.prototype;
Object.entries(fns__namespace.units).forEach(([, method]) => {
  const fn = function(val) {
    if (val == null) {
      return get(this._d, method);
    }
    set(this._d, method, val);
    return this;
  };
  proto[method] = fn;
  if (method !== "time") {
    proto[`${method}s`] = fn;
  }
});
const exclude = ["compile", "parse", "units"];
Object.entries(fns__namespace).forEach(([name, method]) => {
  if (!exclude.includes(name)) {
    proto[name] = function() {
      const date = this._d;
      const ret = method(date, ...arguments);
      return ret === date ? this : ret;
    };
  }
  DateChain[name] = method;
});
function chain(input, format) {
  return new DateChain(input, format);
}
exports.chain = chain;
Object.keys(fns).forEach((k) => {
  if (k !== "default" && !Object.prototype.hasOwnProperty.call(exports, k)) Object.defineProperty(exports, k, {
    enumerable: true,
    get: () => fns[k]
  });
});
